counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- rank_values - min(rank_values) + 1
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign colors based on threshold
edge_colors <- ifelse(edge_weights < AI_threshold, "white", "grey")
# Set edge colors in the network object
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "grey",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = 0.5
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
plot_list[[3]][[3]] # After SD
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Select the appropriate ranking column
rank_column <- rank_columns[j]
j=1
# Select the appropriate ranking column
rank_column <- rank_columns[j]
rank_column
i=1
j=1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
node_colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
filtered_df[[rank_column]]
rank_values
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
rank_values
rank_values - min(rank_values)
rank_values - min(rank_values) + 1
rank_values - min(rank_values) + 0.1
rank_values + 0.1
round(rank_values + 0.1, 2)
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
# Initialize a list to store layout information for each graph
layout_list <- vector("list", length(net))
# Function to generate random layout
generate_random_layout <- function(net) {
num_nodes <- network.size(net)
layout <- matrix(runif(2 * num_nodes), ncol = 2)
return(layout)
}
# Generate random layouts for each network in the list
for (i in 1:length(net)) {
layout_list[[i]] <- generate_random_layout(net[[i]])
}
# Generate a color palette
result_df$colors <- viridis(length(result_df$Strength),
option = "plasma")[as.numeric(cut(result_df$Strength,
breaks = length(result_df$Strength)))]
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Set AI threshold (adjust as needed)
AI_threshold <- 0.1
# Create an empty list with dimensions num_i x num_j
plot_list <- vector("list", 3)
for (i in seq_along(plot_list)) {
plot_list[[i]] <- vector("list", 3)
}
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[3]]
counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- round(rank_values + 0.2, 2)
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign colors based on threshold
edge_colors <- ifelse(edge_weights < AI_threshold, "white", "grey")
# Set edge colors in the network object
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "color",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = 0.5
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
i=1
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
median(edge_weights)
i=2
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
median(edge_weights)
i=3
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
median(edge_weights)
i=1
j=1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
round(rank_values + 0.2, 2)
rank_values
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
# Initialize a list to store layout information for each graph
layout_list <- vector("list", length(net))
# Function to generate random layout
generate_random_layout <- function(net) {
num_nodes <- network.size(net)
layout <- matrix(runif(2 * num_nodes), ncol = 2)
return(layout)
}
# Generate random layouts for each network in the list
for (i in 1:length(net)) {
layout_list[[i]] <- generate_random_layout(net[[i]])
}
# Generate a color palette
result_df$colors <- viridis(length(result_df$Strength),
option = "plasma")[as.numeric(cut(result_df$Strength,
breaks = length(result_df$Strength)))]
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Set AI threshold (adjust as needed)
AI_threshold <- 0.01
# Create an empty list with dimensions num_i x num_j
plot_list <- vector("list", 3)
for (i in seq_along(plot_list)) {
plot_list[[i]] <- vector("list", 3)
}
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[3]]
counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- round(rank_values + 0.5, 2)
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign colors based on threshold
edge_colors <- ifelse(edge_weights < AI_threshold, "white", "grey")
# Set edge colors in the network object
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "color",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = 0.5
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
ifelse(edge_weights < AI_threshold, rgb(1, 1, 1, alpha = 0.2), rgb(0.5, 0.5, 0.5, alpha = 0.5))
plot_list[[3]][[3]] # After SD
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
# Initialize a list to store layout information for each graph
layout_list <- vector("list", length(net))
# Function to generate random layout
generate_random_layout <- function(net) {
num_nodes <- network.size(net)
layout <- matrix(runif(2 * num_nodes), ncol = 2)
return(layout)
}
# Generate random layouts for each network in the list
for (i in 1:length(net)) {
layout_list[[i]] <- generate_random_layout(net[[i]])
}
# Generate a color palette
result_df$colors <- viridis(length(result_df$Strength),
option = "plasma")[as.numeric(cut(result_df$Strength,
breaks = length(result_df$Strength)))]
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Set AI threshold (adjust as needed)
AI_threshold <- 0.01
# Set AI threshold (adjust as needed)
AI_threshold <- 0.05
# Create an empty list with dimensions num_i x num_j
plot_list <- vector("list", 3)
for (i in seq_along(plot_list)) {
plot_list[[i]] <- vector("list", 3)
}
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[3]]
counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- round(rank_values + 0.5, 2)
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign colors based on threshold
edge_colors <- ifelse(edge_weights < AI_threshold, rgb(1, 1, 1, alpha = 0.2), rgb(0.5, 0.5, 0.5, alpha = 0.5))
# Set edge colors in the network object
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "color",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = 0.5
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
# Initialize a list to store layout information for each graph
layout_list <- vector("list", length(net))
# Function to generate random layout
generate_random_layout <- function(net) {
num_nodes <- network.size(net)
layout <- matrix(runif(2 * num_nodes), ncol = 2)
return(layout)
}
# Generate random layouts for each network in the list
for (i in 1:length(net)) {
layout_list[[i]] <- generate_random_layout(net[[i]])
}
# Generate a color palette
result_df$colors <- viridis(length(result_df$Strength),
option = "plasma")[as.numeric(cut(result_df$Strength,
breaks = length(result_df$Strength)))]
# Define mapping between ranking columns
rank_columns <- c("Prop_BG", "Prop_FG", "Prop_SD")
# Set AI threshold (adjust as needed)
AI_threshold <- 0.05
# Create an empty list with dimensions num_i x num_j
plot_list <- vector("list", 3)
for (i in seq_along(plot_list)) {
plot_list[[i]] <- vector("list", 3)
}
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[3]]
counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- round(rank_values + 0.5, 2)
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign edge colors with transparency (white for below threshold, grey for above threshold)
edge_colors <- ifelse(edge_weights < AI_threshold, "white", "grey")
# Assign edge alpha transparency based on weight threshold
edge_alpha <- ifelse(edge_weights < AI_threshold, 0.2, 0.5)  # Set transparency level
# Set edge color and alpha transparency
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
net[[i]] %e% "alpha" <- edge_alpha  # Assign alpha transparency
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "color",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = "alpha"
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
i=1
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign edge alpha transparency based on weight threshold
edge_alpha <- ifelse(edge_weights < AI_threshold, 0.2, 0.5)  # Set transparency level
edge_alpha
net[[i]] %e% "alpha" <- edge_alpha  # Assign alpha transparency
?ggnet2
# Create an empty list with dimensions num_i x num_j
plot_list <- vector("list", 3)
for (i in seq_along(plot_list)) {
plot_list[[i]] <- vector("list", 3)
}
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[3]]
counter <- 0
for (i in 1:length(net)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- HI_list[[j]][[i]]  # Fixed index here
# Filter the dataframe for the period
period_val <- unique(result_df$Period)[i]
filtered_df <- subset(result_df, Period == period_val)
# Select the appropriate ranking column
rank_column <- rank_columns[j]
# Match the filtered dataframe to the vertex names in the graph object
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
filtered_df <- filtered_df[matched_indices, ]
# Match node colors
node_colors <- filtered_df$colors
# Filter the dataframe for the period and HI
filtered_df <- subset(filtered_df, ID %in% labeled_nodes)
matched_indices <- match(net[[i]] %v% "vertex.names", filtered_df$ID)
# Handle NA values in matched_colors by assigning "black"
node.colors <- ifelse(is.na(matched_indices), "black", node_colors)
# Extract ranking values and scale node sizes accordingly
rank_values <- filtered_df[[rank_column]]
scaled_sizes <- round(rank_values + 0.5, 2)
# Assign node sizes based on rankings, setting non-engaged nodes to a small size
node.sizes <- ifelse(node.colors == "black", 0.1, scaled_sizes)
# ---- Edge Filtering Based on AI Threshold ----
edge_weights <- net[[i]] %e% "weight"  # Extract edge weights
# Assign edge colors with transparency (white for below threshold, grey for above threshold)
edge_colors <- ifelse(edge_weights < AI_threshold, "white", "grey")
# Assign edge alpha transparency based on weight threshold
edge_alpha <- ifelse(edge_weights < AI_threshold, 0.2, 0.5)  # Set transparency level
# Set edge color and alpha transparency
net[[i]] %e% "color" <- edge_colors  # Assign color attribute to edges
net[[i]] %e% "alpha" <- edge_alpha  # Assign alpha transparency
# Create the plot
net_plot <- ggnet2(net[[i]],
mode = combined_layout,
edge.size = "weight", # edge thickness
edge.color = "color",
size = node.sizes,
node.label = labeled_nodes,
label.color = "white",
label.size = 2,
node.color = node.colors,
edge.alpha = "alpha"
)
plot_list[[j]][[i]] <- net_plot
}
}
plot_list[[1]][[1]] # Before BG
net[[i]] %e% "alpha"
