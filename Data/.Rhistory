}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N40_t, c(changeN20, changeN30, changeN40))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylim = range(c(changeN20, changeN30, changeN40)), ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
# Plot the first population
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Time', main = 'Population Changes Over Time')
N=1:500
dndt=r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
?abline
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2, lwd = 1.5)
abline(h = 40, lty = 2)
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.3
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.4
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size")
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 1)))
(max(N_small) + 50)
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
N_small
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 50)))
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
gc()
gc()
dist = matrix(c(0,5,1,8,5,0,6,3,1,6,0,9,8,3,9,0), nrow = 4, ncol = 4)
dist
1-(dist / max(dist))
gc()
setwd("C:/Users/bankh/My_Repos/dolphin-centrality/Code")
# Set working directory here
setwd("../Data")
# Read in data
result_df <- read.csv("result_df.csv")
# Read in data
result_df <- read.csv("result_df.csv")
setwd("C:/Users/bankh/My_Repos/dolphin-centrality/Code")
# Set working directory here
setwd("../Data")
# Read in data
result_df <- read.csv("result_df.csv")
# Read in data
result_df <- readRDS("result_df.RData")
# Make ID numeric
result_df$numeric_ID <- as.numeric(factor(result_df$ID))
# Make sure there is only one ID in each period
result_df <- result_df[!duplicated(result_df[c("Period", "ID")]), ]
## Check distributions
hist(result_df$Strength) # normal
hist(log(result_df$Strength))
## Check distributions
hist(result_df$Strength) # normal
if(!require(brms)){install.packages('brms'); library(brms)} # For brm modellibrary(coda)
if(!require(bayesplot)){install.packages('bayesplot'); library(bayesplot)} # plot parameters
if(!require(doParallel)){install.packages('doParallel'); library(doParallel)} # Run parallel processing
if(!require(rstan)){install.packages('rstan'); library(rstan)} # To make STAN run faster
if(!require(tidybayes)){install.packages('tidybayes'); library(tidybayes)} # get_variables
# Help STAN run faster
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Set priors
full_priors <- c(
# Prior for Prop_BG
set_prior("normal(0, 1)", class = "b", coef = "Prop_BG"),
# Prior for Prop_FG
set_prior("normal(0, 1)", class = "b", coef = "Prop_FG"),
# Prior for Prop_SD
set_prior("normal(0, 1)", class = "b", coef = "Prop_SD")
)
# Models in brms
fit_sc <- brm(Strength ~
Prop_BG * Period +
Prop_FG * Period +
Prop_SD * Period +
(1 | numeric_ID),
chains = 4, iter = 4000, warmup = 3000,
family = lognormal(), data = result_df, prior = full_priors)
## Check distributions
hist(result_df$Strength) # normal
result_df$Strength <- result_df$Strength + 0.0001  # Add a small value to shift all data to positive
# Set priors
full_priors <- c(
# Prior for Prop_BG
set_prior("normal(0, 1)", class = "b", coef = "Prop_BG"),
# Prior for Prop_FG
set_prior("normal(0, 1)", class = "b", coef = "Prop_FG"),
# Prior for Prop_SD
set_prior("normal(0, 1)", class = "b", coef = "Prop_SD")
)
# Models in brms
fit_sc <- brm(Strength ~
Prop_BG * Period +
Prop_FG * Period +
Prop_SD * Period +
(1 | numeric_ID),
chains = 4, iter = 4000, warmup = 3000,
family = lognormal(), data = result_df, prior = full_priors)
summary(fit_sc)
# Check for model convergence
model <- fit_sc
plot(model)
pp_check(model) # check to make sure they line up
## Period Centrality
theme_update(text = element_text(family = "sans"))
# Create mcmc_areas plot
mcmc_plot <- mcmc_intervals(
as.array(model),
pars = c("b_Period3MAfter_HAB", "b_Period2MDuring_HAB"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) +
labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) +
theme_minimal() + # Use a minimal theme
theme(
text = element_text(family = "sans"), # Set text family
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
panel.background = element_blank(), # Remove panel background
axis.line = element_line(color = "black") # Add axis lines
)
if(!require(GGally)){install.packages('GGally'); library(GGally)} # For mapping networks in ggplot
if(!require(ggraph)){install.packages('ggraph'); library(ggraph)}
if(!require(ggpattern)){install.packages('ggpattern'); library(ggpattern)} # geom_tile_pattern
if(!require(grid)){install.packages('grid'); library(grid)}
if(!require(viridis)){install.packages('viridis'); library(viridis)} # plot themes
if(!require(ggplot2)){install.packages('ggplot2'); library(ggplot2)}
## Network
if(!require(network)){install.packages('network'); library(network)} # For assigning coordinates to nodes %v%
if(!require(RColorBrewer)){install.packages('RColorBrewer'); library(RColorBrewer)} # For strength gradient network colors
if(!require(tnet)){install.packages('tnet'); library(tnet)} # For weights
if(!require(igraph)){install.packages('igraph'); library(igraph)} # Measure centrality here
if(!require(assortnet)){install.packages('assortnet'); library(assortnet)} # associative indices
source("../code/functions.R") # Matrix_to_edge_list
## LMM Test
if(!require(lme4)){install.packages('lme4'); library(lme4)}
if(!require(nlme)){install.packages('nlme'); library(nlme)}
if(!require(lmerTest)){install.packages('lmerTest'); library(lmerTest)}
## Bayesian
if(!require(abind)){install.packages('abind'); library(abind)} # array
if(!require(brms)){install.packages('brms'); library(brms)} # For brm modellibrary(coda)
if(!require(bayesplot)){install.packages('bayesplot'); library(bayesplot)} # plot parameters
if(!require(doParallel)){install.packages('doParallel'); library(doParallel)} # Run parallel processing
if(!require(rstan)){install.packages('rstan'); library(rstan)} # To make STAN run faster
if(!require(tidybayes)){install.packages('tidybayes'); library(tidybayes)} # get_variables
# Create mcmc_areas plot
mcmc_plot <- mcmc_intervals(
as.array(model),
pars = c("b_Period3MAfter_HAB", "b_Period2MDuring_HAB"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) +
labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) +
theme_minimal() + # Use a minimal theme
theme(
text = element_text(family = "sans"), # Set text family
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
panel.background = element_blank(), # Remove panel background
axis.line = element_line(color = "black") # Add axis lines
)
mcmc_plot + scale_y_discrete(
labels = c(
"b_Period2MDuring_HAB" = "During HAB",
"b_Period3MAfter_HAB" = "After HAB"
)
)
## BG
# Create mcmc_areas plot
mcmc_plot <- mcmc_intervals(
as.array(model),
pars = c("b_Prop_BG:Period2MDuring_HAB", "b_Prop_BG:Period3MAfter_HAB",
"b_Prop_BG"),
prob = 0.90, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) +
labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) +
theme_minimal() + # Use a minimal theme
theme(
text = element_text(family = "sans"), # Set text family
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
panel.background = element_blank(), # Remove panel background
axis.line = element_line(color = "black") # Add axis lines
)
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_BG" = "Begging/Provisioning",
"b_Prop_BG:Period2MDuring_HAB" = "BG: During",
"b_Prop_BG:Period3MAfter_HAB" = "BG: After"
)
)
## FG
mcmc_plot <- mcmc_intervals(
as.array(model),
pars = c("b_Period2MDuring_HAB:Prop_FG", "b_Period3MAfter_HAB:Prop_FG",
"b_Prop_FG"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) +
labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) +
theme_minimal() + # Use a minimal theme
theme(
text = element_text(family = "sans"), # Set text family
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
panel.background = element_blank(), # Remove panel background
axis.line = element_line(color = "black") # Add axis lines
)
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_FG" = "Fixed Gear Foraging",
"b_Period2MDuring_HAB:Prop_FG" = "FG: During",
"b_Period3MAfter_HAB:Prop_FG" = "FG: After"
)
)
## SD
mcmc_plot <- mcmc_intervals(
as.array(model),
pars = c("b_Period2MDuring_HAB:Prop_SD", "b_Period3MAfter_HAB:Prop_SD",
"b_Prop_SD"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) +
labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) +
theme_minimal() + # Use a minimal theme
theme(
text = element_text(family = "sans"), # Set text family
panel.grid.major = element_blank(), # Remove major grid lines
panel.grid.minor = element_blank(), # Remove minor grid lines
panel.background = element_blank(), # Remove panel background
axis.line = element_line(color = "black") # Add axis lines
)
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_SD" = "Scavenging/Depredating",
"b_Period2MDuring_HAB:Prop_SD" = "SD: During",
"b_Period3MAfter_HAB:Prop_SD" = "SD: After"
)
)
result_df$Strength <- result_df$Strength + 0.000001  # Add a small value to shift all data to positive
# Read in data
result_df <- readRDS("result_df.RData")
# Make ID numeric
result_df$numeric_ID <- as.numeric(factor(result_df$ID))
# Make sure there is only one ID in each period
result_df <- result_df[!duplicated(result_df[c("Period", "ID")]), ]
result_df$Strength <- result_df$Strength + 0.000001  # Add a small value to shift all data to positive
## Check distributions
hist(result_df$Strength) # normal
hist(log(result_df$Strength))
# Help STAN run faster
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Set priors
full_priors <- c(
# Prior for Prop_BG
set_prior("normal(0, 1)", class = "b", coef = "Prop_BG"),
# Prior for Prop_FG
set_prior("normal(0, 1)", class = "b", coef = "Prop_FG"),
# Prior for Prop_SD
set_prior("normal(0, 1)", class = "b", coef = "Prop_SD")
)
# Models in brms
fit_sc <- brm(Strength ~
Prop_BG * Period +
Prop_FG * Period +
Prop_SD * Period +
(1 | numeric_ID),
chains = 4, iter = 4000, warmup = 3000,
family = lognormal(), data = result_df, prior = full_priors)
# Check for model convergence
model <- fit_sc
pp_check(model) # check to make sure they line up
